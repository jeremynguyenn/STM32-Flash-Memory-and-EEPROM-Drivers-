#include <stdio.h>
#include "stm32f4xx.h"
#include "fpu.h"
#include "uart.h"
#include "timebase.h"
#include "bsp.h"
#include "adc.h"
#include "spi.h"
#include "w25qxx.h"
#include <string.h>



extern SPI_HandleTypeDef hspi1;
W25QXX_t  w25qxx;

W25QXX_Status_t status;

static void dump_hex_data_to_serial(const char *header, uint32_t start_address, const uint8_t *buffer, uint32_t length);
static void test_read(void);
static void test_erase(void);
static void set_test_buffer(uint8_t test_byte, uint8_t *buf, uint32_t len);
static void test_write(void);
static void test_read_all_sectors(void);
static void test_write_all_sectors(void);


int main()
{
	/*Enable FPU*/
	fpu_enable();

	/*Initialize timebase*/
	timebase_init();

	/*Initialize debug UART*/
	debug_uart_init();



	w25qxx_spi_init();

	w25qxx_cs_pin_init();

	status = w25qxx_init(&w25qxx,&hspi1);

	 printf("System init....\n\r");

	if(status == W25QXX_DEV_OK)
	{
		w25qxx_get_mem_info(w25qxx);
	}



	//test_erase();

	//test_write();

	test_write_all_sectors();
	test_read_all_sectors();
	while(1)
	{

	}
}


static void test_read_all_sectors(void)
{
	uint8_t buf[w25qxx.w25qxx_pg_sz];
	uint32_t st_time, ed_time;
	uint32_t total_sectors = w25qxx.w25qxx_blk_cnt * w25qxx.w25qxx_sect_in_blk;

	printf("------------------Read data in all sectors-------------- \n\r");
	st_time = get_tick();

	for (uint32_t i = 0; i < total_sectors; ++i) {
		w25qxx_read(&w25qxx, i * w25qxx.w25qxx_sect_sz, buf, sizeof(buf));
	}

	ed_time = get_tick();

	printf("Time taken :  %lu ms\n\r", ed_time - st_time);

}

static void test_write_all_sectors(void)
{
	uint8_t buf[w25qxx.w25qxx_pg_sz];

	uint32_t st_time, ed_time;

	set_test_buffer(0xDE, buf, sizeof(buf));

	uint32_t total_sectors = w25qxx.w25qxx_blk_cnt * w25qxx.w25qxx_sect_in_blk;


	printf("------------------Write data to all sectors-------------- \n\r");
	st_time = get_tick();
	for (uint32_t i = 0; i < total_sectors; ++i)
	{
		w25qxx_write(&w25qxx, i * w25qxx.w25qxx_sect_sz, buf, sizeof(buf));
	}
	ed_time = get_tick();

	printf("Time taken :  %lu ms\n\r", ed_time - st_time);


}

static void dump_hex_data_to_serial(const char *header, uint32_t start_address, const uint8_t *buffer, uint32_t length)
{
    // Print the header text
    printf("%s\n", header);

    // Loop through the buffer
    for (uint32_t i = 0; i < length; ++i) {


        // Check if we need to print a new line and the starting address
        if (i % 16 == 0) {
            printf("0x%08lx: ", start_address);
        }

        // Print the hexadecimal value of the current buffer element
        printf("%02x ", buffer[i]);

        // Check if we need to print a new line
        if ((i + 1) % 16 == 0) {
            printf("\n");
        }

        // Increment the starting address
        ++start_address;
    }


}

static void test_read(void)
{
	uint8_t buf[w25qxx.w25qxx_pg_sz];

	status = w25qxx_read(&w25qxx, 0, (uint8_t*) &buf, sizeof(buf));

	if(status == W25QXX_DEV_OK)
	{
		dump_hex_data_to_serial("<----PAGE START--->", 0, (uint8_t*) &buf, sizeof(buf));

	}
	else
	{
		printf("ERROR :  Cannot Read\n\r");
	}

}


static void test_erase(void)
{
	uint8_t buf[w25qxx.w25qxx_pg_sz];

	if(w25qxx_erase(&w25qxx, 0, sizeof(buf)) == W25QXX_DEV_OK)
	{
		test_read();
	}

}

static void set_test_buffer(uint8_t test_byte, uint8_t *buf, uint32_t len)
{
    memset(buf, test_byte, len);

}

static void test_write(void)
{
	uint8_t buf[w25qxx.w25qxx_pg_sz];

	set_test_buffer(0xBE,buf,sizeof(buf));

	if (w25qxx_write(&w25qxx, 0, (uint8_t*) &buf, sizeof(buf)) == W25QXX_DEV_OK)
	{
		delay(10);

		test_read();
	}

}


